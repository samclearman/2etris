import * as firebase from "firebase/app";

import "firebase/database";
import * as seedrandom from "seedrandom";

const NEW_GAME = true;

// Initialize Firebase
var config = {
  apiKey: "AIzaSyD_jPrtfw6F6JmMxJxpnHJx43epldCWEr8",
  authDomain: "etris-ab596.firebaseapp.com",
  databaseURL: "https://etris-ab596.firebaseio.com",
  storageBucket: "etris-ab596.appspot.com",
  messagingSenderId: "996840504095"
};
firebase.initializeApp(config);
const db = firebase.database()

// const output = document.getElementById("fb_test");
// db.ref('text').on("value", snap => (output.innerText = snap.val()));

// stolen from https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}


const gridWidth = 10;
const gridHeight = 20;

enum Player {
  One,
  Two
}

const playerColors = {
  [Player.One]: "black",
  [Player.Two]: "white"
};

type Vector = { dx: number, dy: number };

type Direction = 1 | -1;

enum Shape {
  I,
  O,
  J,
  L,
  T,
  S,
  Z
}

type Mask = number[][];

const masks = {
  [Shape.I]: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
  // [Shape.O]: [[0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
  [Shape.O]: [[1, 1], [1, 1]],
  [Shape.J]: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
  [Shape.L]: [[0, 0, 1], [1, 1, 1], [0, 0, 0]],
  [Shape.T]: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
  [Shape.S]: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
  [Shape.Z]: [[1, 1, 0], [0, 1, 1], [0, 0, 0]]
};

const spawnOffsets = {
  [Shape.I]: { x: 0, y: -2},
  [Shape.O]: { x: 0, y: -2},
  [Shape.J]: { x: 0, y: -2},
  [Shape.L]: { x: 0, y: -2},
  [Shape.T]: { x: 0, y: -2},
  [Shape.S]: { x: 0, y: -2},
  [Shape.Z]: { x: 0, y: -2},  
};

function spawnOffset(shape: Shape) {
  if (shape in spawnOffsets) {
    return spawnOffsets[shape];
  }
  return { x: 0, y: 0 };
}

function kicks(omino, direction) {
  if ([Shape.J, Shape.L, Shape.S, Shape.T, Shape.Z].includes(omino.shape)) {
    if (omino.rotation === 1) {
      return [
        { dx: 0, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: -1, dy: 1 },
        { dx: 0, dy: -2 },
        { dx: -1, dy: -2 }
      ];
    } else if (omino.rotation - direction === 1) {
      return [
        { dx: 0, dy: 0 },
        { dx: 1, dy: 0 },
        { dx: 1, dy: -1 },
        { dx: 0, dy: 2 },
        { dx: 1, dy: 2 }
      ];
    } else if (omino.rotation === 3) {
      return [
        { dx: 0, dy: 0 },
        { dx: 1, dy: 0 },
        { dx: 1, dy: 1 },
        { dx: 0, dy: -2 },
        { dx: 1, dy: -2 }
      ];
    } else if ((omino.rotation - direction + 4) % 4 === 3) {
      return [
        { dx: 0, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: -1, dy: -1 },
        { dx: 0, dy: 2 },
        { dx: -1, dy: 2 }
      ];
    } else {
      throw "that shouldn't happen";
    }
  } else if (omino.shape === Shape.I) {
    if (
      (omino.rotation === 1 && direction === 1) ||
      (omino.rotation === 2 && direction === -1)
    ) {
      return [
        { dx: 0, dy: 0 },
        { dx: -2, dy: 0 },
        { dx: 1, dy: 0 },
        { dx: -2, dy: -1 },
        { dx: 1, dy: 2 }
      ];
    } else if (
      (omino.rotation === 0 && direction === -1) ||
      (omino.rotation === 3 && direction === 1)
    ) {
      return [
        { dx: 0, dy: 0 },
        { dx: 2, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 2, dy: 1 },
        { dx: -1, dy: -2 }
      ];
    } else if (
      (omino.rotation === 2 && direction === 1) ||
      (omino.rotation === 3 && direction === -1)
    ) {
      return [
        { dx: 0, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 2, dy: 0 },
        { dx: -1, dy: 2 },
        { dx: 2, dy: -1 }
      ];
    } else if (
      (omino.rotation === 1 && direction === -1) ||
      (omino.rotation === 0 && direction === 1)
    ) {
      return [
        { dx: 0, dy: 0 },
        { dx: 1, dy: 0 },
        { dx: -2, dy: 0 },
        { dx: 1, dy: -2 },
        { dx: -2, dy: 1 }
      ];
    } else {
      throw "that shouldn't happen";
    }
  } else {
    // its a O
    return [];
  }
}

interface Omino {
  shape: Shape
  rotation: 0 | 1 | 2 | 3,
  mask: Mask
  player: Player
  x: number,
  y: number,
  nextFall: number,
  speed: number,
}

enum EventType {
  Rotate,
  Move,
  Drop,
  Spawn,
  Fall,
  Init,
  Claim
}

interface IEvent {
  t: EventType;
  time: number;
}

interface Rotate extends IEvent {
  t: EventType.Rotate;
  player: number;
  direction: 1 | -1;
}

interface Move extends IEvent {
  t: EventType.Move;
  player: number;
  direction: 1 | -1;
}

interface Drop extends IEvent {
  t: EventType.Drop;
  player: number;
}

interface Spawn extends IEvent {
  t: EventType.Spawn;
  player: number;
  shape: Shape;
}

interface Fall extends IEvent {
  t: EventType.Fall;
  player: number;
}

interface Init extends IEvent {
  t: EventType.Init;
  seed: string;
}

interface Claim extends IEvent {
  t: EventType.Claim;
  user: string;
  player: number;
  both?: boolean;
}

type E = Rotate | Move | Drop | Spawn | Fall | Init | Claim;



function copyMask(m: Mask) {
  return m.map(r => r.map(b => b));
}

function rotatedMask(mask: Mask, d: 1 | -1): Mask {
  const rotated = [];
  if (d === -1) {
    for (let i = 0; i < mask.length; i++) {
      rotated.push([]);
      for (let j = 0; j < mask.length; j++) {
        rotated[i][j] = mask[j][mask.length - 1 - i];
      }
    }
  } else {
    for (let i = 0; i < mask.length; i++) {
      rotated.push([]);
      for (let j = 0; j < mask.length; j++) {
        rotated[i][j] = mask[mask.length - 1 - j][i];
      }
    }
  }
  return rotated;
}

function playerMaskTransform(player: Player, mask: Mask): Mask {
  if (player === Player.Two) {
    const n = mask.length;
    const transformed = [];
    for (let i = 0; i < n; i++) {
      transformed.push([]);
      for (let j = 0; j < n; j++) {
        transformed[i][j] = mask[n - 1 - i][n - 1 - j];
      }
    }
    return transformed;
  }
  return copyMask(mask);
}

function globalCoordPositions(omino: Omino, { dx, dy }: Vector) {
  const { mask, player } = omino;
  const positions = [];
  for (let i = 0; i < mask.length; i++) {
    for (let j = 0; j < mask[i].length; j++) {
      if (mask[i][j]) {
        const x = j + omino.x + dx;
        let y = i + omino.y + dy;
        if (player === Player.Two) {
          y = gridHeight - 1 - y;
        }
        positions.push({ x, y });
      }
    }
  }
  return positions;
}

function copyOmino(o: Omino): Omino {
  return {
    shape: o.shape,
    player: o.player,
    rotation: o.rotation,
    mask: copyMask(o.mask),
    x: o.x,
    y: o.y,
    nextFall: o.nextFall,
    speed: o.speed
  };
}

function newOmino(
  shape: Shape,
  player: Player,
  createdAt: number,
  speed: number
) {
  const mask = masks[shape];
  const x = Math.floor((gridWidth - mask[0].length) / 2) + spawnOffset(shape).x;
  const y = spawnOffset(shape).y;
  return {
    shape,
    rotation: 0,
    mask,
    player,
    x,
    y,
    nextFall: createdAt + speed,
    speed: speed
  };
}

enum SessionState {
  Claiming,
  Playing,
  Over,
}

function newSession(me) {
  return {
    me,
    state: SessionState.Claiming,
    users: [] as string[],
    claims: {
      [Player.One]: null,
      [Player.Two]: null,
    },
    game: null,
  }
}

function level(game) {
  return Math.floor(game.lines / 10) + 1;
}

function speed(game) {
  const l = level(game) - 1;
  return 1000 * ((0.8 * (l * 0.007)) ** l);
}

function newGame(e: Init) {
  const rng = seedrandom(e.seed.toString());
  return {
    lines: 0,
    score: 0,
    active: true,
    over: false,
    rng,
    grid: [
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ],
    activeOminos: {
      [Player.One]: newOmino(Shape.S, Player.One, e.time, 1000),
      [Player.Two]: newOmino(Shape.S, Player.Two, e.time, 1000)
    },
  };
}


function checkCollision(game, omino, { dx, dy }) {
  for (const { x, y } of globalCoordPositions(omino, { dx, dy })) {
    if (game.grid[y] && game.grid[y][x] === omino.player) {
      return true;
    }
    if (x < 0 || x >= gridWidth) {
      return true;
    }
  }
  return false;
}

function checkLine(game, player, y) {
  for (let x = 0; x < gridWidth; x++) {
    if (game.grid[y][x] !== player) {
      return false;
    }
  }
  return true;
}

function clearLine(game, player, y) {
  if (player === 0) {
    game.grid = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]].concat(
      game.grid.slice(0, y),
      game.grid.slice(y + 1)
    );
  } else {
    game.grid = game.grid
      .slice(0, y)
      .concat(game.grid.slice(y + 1), [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]);
  }
}

function score(game, lines) {
  return [0,100,300,500,800][lines] * level(game);
}

function freeze(game, omino) {
  const yToCheck = new Set();
  for (const { x, y } of globalCoordPositions(omino, { dx: 0, dy: 0 })) {
    // Todo: the grid should extend beyond the visible area, this check should happen at the end of freeze
    if (y < 0 || y >= gridHeight) {
      game.over = true;
      return;
    }
    game.grid[y][x] = omino.player;
    yToCheck.add(y);
  }
  let lines = 0;
  const order = omino.player === 0 ? (a, b) => a - b : (a, b) => b - a;
  for (const y of Array.from(yToCheck).sort(order)) {
    if (checkLine(game, omino.player, y)) {
      clearLine(game, omino.player, y);
      lines += 1;
    }
  }
  game.lines += lines;
  game.score += score(game, lines);
}

function randomShape(rng: () => number) {
  const x = rng();
  if (x < 0 || x >= 1) {
    throw "Random  number outside of the usual range";
  }
  return Math.floor(rng() * 7) as Shape;
}

const eventHandlers = {
  [EventType.Spawn]: function(e: Spawn, game) {
    game.activeOminos[e.player] = newOmino(
      e.shape,
      e.player,
      e.time,
      speed(game)
    );
    return game;
  },
  [EventType.Move]: function(e: Move, game) {
    const o = copyOmino(game.activeOminos[e.player]);
    o.x += e.direction;
    if (!checkCollision(game, o, { dx: 0, dy: 0 })) {
      game.activeOminos[e.player] = o;
    }
    return game;
  },
  [EventType.Rotate]: function(e: Rotate, game) {
    const o = copyOmino(game.activeOminos[e.player]);
    o.rotation = (o.rotation + e.direction + 4) % 4 as 0 | 1 | 2 | 3;
    o.mask = rotatedMask(o.mask, e.direction);
    for (const { dx, dy } of kicks(o, e.direction)) {
      if (!checkCollision(game, o, { dx, dy })) {
        o.x += dx;
        o.y += dy;
        game.activeOminos[e.player] = o;
        return game;
      }
    }
    return game;
  },
  [EventType.Drop]: function(e: Drop, game) {
    const o = copyOmino(game.activeOminos[e.player]);
    let drop = 0;
    while (!checkCollision(game, o, { dx: 0, dy: drop })) {
      drop += 1;
    }
    drop -= 1;
    o.y += drop;
    if (drop !== 0) {
      o.nextFall = e.time + o.speed;
    }
    game.activeOminos[e.player] = o;
    return game;
  },
  [EventType.Fall]: function(e: Fall, game) {
    const o = copyOmino(game.activeOminos[e.player]);
    if (!checkCollision(game, o, { dx: 0, dy: 1 })) {
      o.y += 1;
      o.nextFall += o.speed;
      game.activeOminos[e.player] = o;
    } else {
      freeze(game, o);
      game.activeOminos[e.player] = newOmino(
        randomShape(game.rng),
        e.player,
        e.time,
        speed(game),
      );
    }
    return game;
  },
};

function processEvent(e: E, game) {
  if (!eventHandlers[e.t]) {
    console.warn(`Unsupported event: ${e.t}`);
    return game
  }
  return eventHandlers[e.t](e, game);
}

const w = 20;

const controls = {
  // Test controls
  // KeyS: {
  //   t: EventType.Rotate,
  //   player: Player.Two,
  //   direction: 1
  // },
  // KeyQ: {
  //   t: EventType.Move,
  //   player: Player.Two,
  //   direction: -1
  // },
  // KeyW: {
  //   t: EventType.Drop,
  //   player: Player.Two
  // },
  // KeyE: {
  //   t: EventType.Move,
  //   player: Player.Two,
  //   direction: 1
  // },
  ArrowUp: {
    t: EventType.Rotate,
    direction: 1
  },
  ArrowLeft: {
    t: EventType.Move,
    direction: -1
  },
  ArrowRight: {
    t: EventType.Move,
    direction: 1
  },
  ArrowDown: {
    t: EventType.Drop,
  },
};

function render(ctx, game, transform) {
  for (let i = 0; i < game.grid.length; i++) {
    for (let j = 0; j < game.grid[i].length; j++) {
      ctx.fillStyle = playerColors[game.grid[i][j]];
      const { x, y } = transform({ x: j, y: i});
      ctx.fillRect(x * w, y * w, w, w);
    }
  }
  for (const p in Player) {
    ctx.fillStyle = playerColors[p];
    const o = game.activeOminos[p];
    if (!o) {
      continue;
    }
    const positions = globalCoordPositions(o, { dx: 0, dy: 0 }).map(p => transform(p));
    for (const { x, y } of positions) {
      ctx.fillRect(x * w, y * w, w, w);
    }
    // renderMask(ctx, o.mask, playerColors[o.player], o.x, o.y);
  }
}

function tickEvent(o): Fall {
  return {
    t: EventType.Fall,
    time: o.nextFall,
    player: o.player
  };
}

function computeSession(session, events: E[], end: number) {
  let i = 0;
  const nextEvent = function() {
    if (session.state !== SessionState.Playing) {
      i++;
      return events [i - 1];
    }
    const game = session.game!;
    if (
      events[i] &&
      events[i].time < game.activeOminos[Player.One].nextFall &&
      events[i].time < game.activeOminos[Player.Two].nextFall
    ) {
      i++;
      return events[i - 1];
    }
    const n =
      game.activeOminos[Player.One].nextFall <
      game.activeOminos[Player.Two].nextFall
        ? game.activeOminos[Player.One]
        : game.activeOminos[Player.Two];
    return tickEvent(n);
  };
  for (let next = nextEvent(); next && next.time < end; next = nextEvent()) {
    if (next.t === EventType.Init) {
      session.seed = next.seed;
      continue;
    }
    if (next.t === EventType.Claim) {
      if (session.claims[next.player] && session.claims[next.player] !== next.user) {
        continue;
      }
      if (session.claims[1 - next.player] === next.user) {
        session.claims[1 - next.player] = null;
      }
      session.claims[next.player] = next.user;
      if (next.both) {
        session.claims[1 - next.player] = next.user;
      }
      if (session.claims[Player.One] && session.claims[Player.Two]) {
        session.game = newGame({
          time: next.time + 1000,
          t: EventType.Init,
          seed: session.seed,
        })
        session.state = SessionState.Playing;
      }
      continue;
    }
    if (session.state === SessionState.Playing) processEvent(next, session.game);
    if (session.game.over) session.state = SessionState.Over;
  }
  return session;
}

function makeSession(me) {
  const initialEvents: E[] = [{
    time: Date.now(),
    t: EventType.Init,
    seed: Math.random().toString(),
  }]
  const u = new URL(window.location.href);
  if (u.searchParams.has('test')) {
    initialEvents.push({
      time: Date.now(),
      t: EventType.Claim,
      user: me,
      player: Player.One,
      both: true,
    });
  }
  db.ref('sessions').push(initialEvents).then(ref => {
    console.log(ref.key);
    const l = window.location
    const u = new URL(window.location.href)
    u.searchParams.set('session', ref.key)
    history.pushState(u.toString(), u.toString(), u.toString())
    game();
  });
}

function renderClaimer({blackButton, whiteButton, overlay}, session) {
  if (session.state !== SessionState.Claiming) {
    overlay.style.display = 'none';
  }
  for (const [player, button] of [[Player.One, blackButton], [Player.Two, whiteButton]]) {
    if (session.claims[player] === session.me) {
      button.checked = true;
      button.disabled = false;
    } else if (session.claims[player]) {
      button.checked = false;
      button.disabled = true;
    } else {
      button.checked = false;
      button.disabled = false;
    }
  }
}

function renderScore({scoreOutput, linesOutput}, game) {
  scoreOutput.textContent = game.score;
  linesOutput.textContent = game.lines;
}

function identity({x,y}) {
  return {x,y}
}

function flip({x,y}) {
  return {x, y: gridHeight - 1 - y};
}

function game() {
  if (!window.localStorage.getItem('me')) {
    window.localStorage.setItem('me', uuidv4());
  }
  const me = window.localStorage.getItem('me');
  const u = new URL(window.location.href);
  if (!u.searchParams.has('session')) {
    const s = makeSession(me);
    return;
  }

  let session = newSession(me);

  const canvas = <HTMLCanvasElement>document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const overlay = document.getElementById("pregame");
  const blackButton = document.getElementById("black-button");
  const whiteButton = document.getElementById("white-button");
  const scoreOutput = document.getElementById("score");
  const linesOutput = document.getElementById("lines");
  
  const events: E[] = [];
  // @ts-ignore
  if(self.DEBUG_EVENTS) self.DEBUG_EVENTS = events;
  var FB_EVENT_LIST = firebase.database().ref(`sessions/${u.searchParams.get('session')}`);
  FB_EVENT_LIST.on("child_added", function(snapshot) {
    const e = snapshot.val();
    events.push(e);
  });
  window.addEventListener("keydown", function(e) {
    if (!(e.code.toString() in controls)) {
      return;
    }
    const player = session.claims[Player.One] === me ? Player.One : Player.Two
    FB_EVENT_LIST.push(
      Object.assign({ time: Date.now(), player }, controls[e.code.toString()])
    );
    e.preventDefault();
  });
  blackButton.addEventListener('change', function(e) {
    FB_EVENT_LIST.push({
      t: EventType.Claim,
      time: Date.now(),
      user: me,
      player: Player.One,
    });
  });
  whiteButton.addEventListener('change', function(e) {
    FB_EVENT_LIST.push({
      t: EventType.Claim,
      time: Date.now(),
      user: me,
      player: Player.Two,
    });
  });

  // @ts-ignore
  if(self.DEBUG_SESSION) self.DEBUG_SESSION = session;
  const loop = () => {
    computeSession(session, events, Date.now());
    renderClaimer({blackButton, whiteButton, overlay}, session);
    if (session.state === SessionState.Playing || session.state === SessionState.Over) {
      render(ctx, session.game, session.claims[Player.One] === me ? identity : flip);
      renderScore({scoreOutput, linesOutput}, session.game);
    }
    setTimeout(loop, 10);
  };
  loop();
}

game();
